import * as fs from "node:fs";
import { describe, expect, it, vi } from "vitest";
import { EnvParser, parseEnvContent } from "../../src/env-parser";
import { withEnv } from "../helpers/env";

vi.mock("node:fs", () => ({
  existsSync: vi.fn(),
  readFileSync: vi.fn(),
  writeFileSync: vi.fn(),
}));

describe("EnvParser", () => {
  const rootPath = "/fake/root";

  describe("when parsing file content", () => {
    it("should include comments/equals handling and keep raw keys", () => {
      const content = `# comment\nA=1\nB=with=equals\nC = ignored\n`;
      const parsed = parseEnvContent(content);
      expect(parsed).toEqual({ A: "1", B: "with=equals", "C ": " ignored" });
    });

    it("should skip lines without equals sign", () => {
      const content = `VALID=value\nINVALID_NO_EQUALS\nANOTHER=ok\n`;
      const parsed = parseEnvContent(content);
      expect(parsed).toEqual({ VALID: "value", ANOTHER: "ok" });
    });
  });

  describe("when credentials are only in base .env", () => {
    it("should detect Infisical credentials", () => {
      vi.mocked(fs.existsSync).mockReturnValue(true);
      vi.mocked(fs.readFileSync).mockReturnValue(
        "INFISICAL_MACHINE_IDENTITY_CLIENT_ID=id\nINFISICAL_MACHINE_IDENTITY_CLIENT_SECRET=sec\n"
      );
      const parser = new EnvParser(rootPath, vi.mocked(fs.existsSync));
      expect(parser.hasInfisicalCredentials()).toBe(true);
    });
  });

  describe("when writing generated .env.<env>", () => {
    it("should write with header and sorted keys", () => {
      const files: Record<string, string> = {};
      vi.mocked(fs.writeFileSync).mockImplementation(
        (p: unknown, d: unknown) => {
          const key = String(p);
          const content = typeof d === "string" ? d : String(d);
          files[key] = content;
          return undefined as unknown as void;
        }
      );
      const parser = new EnvParser(rootPath, vi.mocked(fs.existsSync));
      parser.setEnvName("dev");
      parser.writeEnvironmentFile({ Z: "z", A: "a", M: "m" });
      const out = files[`${rootPath}/.env.dev`];
      expect(out).toMatch(/automatically generated by env-run/);
      const lines = out.split("\n").filter((l) => l && !l.startsWith("#"));
      expect(lines).toEqual(["A=a", "M=m", "Z=z"]);
    });
  });

  describe("when detecting placeholder credentials", () => {
    it("should return false for placeholder creds in base .env", async () => {
      vi.mocked(fs.existsSync).mockReturnValue(true);
      vi.mocked(fs.readFileSync).mockReturnValue(
        "INFISICAL_MACHINE_IDENTITY_CLIENT_ID=YOUR_INFISICAL_CLIENT_ID\n" +
          "INFISICAL_MACHINE_IDENTITY_CLIENT_SECRET=YOUR_INFISICAL_CLIENT_SECRET\n"
      );
      await withEnv(
        {
          INFISICAL_MACHINE_IDENTITY_CLIENT_ID: undefined,
          INFISICAL_MACHINE_IDENTITY_CLIENT_SECRET: undefined,
        },
        () => {
          const parser = new EnvParser(rootPath, vi.mocked(fs.existsSync));
          expect(parser.hasInfisicalCredentials()).toBe(false);
        }
      );
    });
  });

  describe("when using getter methods", () => {
    it("should return correct values for envName and override file", () => {
      vi.mocked(fs.existsSync).mockReturnValue(false);
      const parser = new EnvParser("/fake/root", vi.mocked(fs.existsSync));
      expect(parser.getEnvName()).toBeUndefined();
      expect(parser.getOverrideEnvFile()).toBeNull();
      parser.setEnvName("prod");
      expect(parser.getEnvName()).toBe("prod");
      expect(parser.getOverrideEnvFile()).toBeNull();
    });
  });

  describe("when writing environment file without envName", () => {
    it("should not write any file", () => {
      vi.mocked(fs.existsSync).mockReturnValue(false);
      vi.mocked(fs.writeFileSync).mockClear();
      const parser = new EnvParser("/fake/root", vi.mocked(fs.existsSync));
      parser.writeEnvironmentFile({ A: "1" });
      expect(vi.mocked(fs.writeFileSync)).not.toHaveBeenCalled();
    });
  });
});
