import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";

// Helper function to parse a .env file content
export function parseEnvContent(content: string): Record<string, string> {
  const env: Record<string, string> = {};
  for (const line of content.split("\n")) {
    const trimmedLine = line.trim();
    if (trimmedLine && !trimmedLine.startsWith("#")) {
      const [key, ...valueParts] = trimmedLine.split("=");
      if (key && valueParts.length > 0) {
        env[key] = valueParts.join("=");
      }
    }
  }
  return env;
}

export class EnvParser {
  private baseEnvFile = "";
  private overrideEnvFile: string | null = null;
  private envName?: string;
  private monorepoRoot: string;
  private fsExistsSync: (_filePath: string) => boolean;

  constructor(monorepoRoot: string, fsExistsSync = existsSync) {
    this.monorepoRoot = monorepoRoot;
    this.baseEnvFile = "";
    this.overrideEnvFile = null;
    this.fsExistsSync = fsExistsSync;

    // Always determine the base .env file path, even without an environment name
    this.determineBaseEnvFile();
  }

  setEnvName(envName: string): void {
    this.envName = envName;
    this.determineEnvFiles();
  }

  private determineBaseEnvFile(): void {
    // Always determine base .env file path, regardless of environment name
    const baseEnvFile = join(this.monorepoRoot, ".env");
    this.baseEnvFile = this.fsExistsSync(baseEnvFile) ? baseEnvFile : "";
  }

  private determineEnvFiles(): void {
    // Determine base .env file (in case it wasn't set in constructor)
    this.determineBaseEnvFile();

    /* v8 ignore start: private guard cannot be reached without envName via public API -- @preserve */
    if (!this.envName) {
      this.overrideEnvFile = null;
      return;
    }
    /* v8 ignore end -- @preserve */

    // Determine environment-specific override file
    const overrideEnvFile = join(this.monorepoRoot, `.env.${this.envName}`);
    this.overrideEnvFile = this.fsExistsSync(overrideEnvFile)
      ? overrideEnvFile
      : null;
  }

  getBaseEnvFile(): string {
    return this.baseEnvFile;
  }

  getOverrideEnvFile(): string | null {
    return this.overrideEnvFile;
  }

  getEnvName(): string | undefined {
    return this.envName;
  }

  shouldUseInfisical(forceRefresh: boolean): boolean {
    const overrideFileExists =
      this.overrideEnvFile && this.fsExistsSync(this.overrideEnvFile);

    if (overrideFileExists && !forceRefresh) {
      return false; // Local override exists and we are not forcing a refresh
    }

    // Check for credentials if no override file or if forcing refresh
    return this.hasInfisicalCredentials();
  }

  hasInfisicalCredentials(): boolean {
    // Attempt to load credentials from the base .env file if not in process.env
    const baseEnvPath = this.getBaseEnvFile();
    let credentialsFromEnvFile: Record<string, string> = {};
    if (baseEnvPath && this.fsExistsSync(baseEnvPath)) {
      const content = readFileSync(baseEnvPath, "utf-8");
      credentialsFromEnvFile = parseEnvContent(content);
    }

    const mergedEnv = { ...credentialsFromEnvFile, ...process.env };

    const clientId = mergedEnv.INFISICAL_MACHINE_IDENTITY_CLIENT_ID;
    const clientSecret = mergedEnv.INFISICAL_MACHINE_IDENTITY_CLIENT_SECRET;

    // Check if both credentials are available and not placeholder values
    return !!(
      clientId &&
      clientSecret &&
      clientId.trim() !== "" &&
      clientSecret.trim() !== "" &&
      clientId !== "YOUR_INFISICAL_CLIENT_ID" &&
      clientSecret !== "YOUR_INFISICAL_CLIENT_SECRET" &&
      !clientId.startsWith("${") &&
      !clientSecret.startsWith("${")
    );
  }

  // Method to write environment variables to .env.{env} file
  writeEnvironmentFile(envVars: Record<string, string>): void {
    if (!this.envName) {
      return;
    }

    const envFileName = join(this.monorepoRoot, `.env.${this.envName}`);
    const comment = `# This file was automatically generated by env-run from Infisical\n# DO NOT EDIT MANUALLY - changes will be overwritten\n# To refresh this file, use: pnpm env-run --env=${this.envName} --force-refresh\n\n`;

    const envContent =
      comment +
      Object.entries(envVars)
        .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
        .map(([key, value]) => `${key}=${value}`)
        .join("\n");

    writeFileSync(envFileName, envContent, "utf8");
  }
}
